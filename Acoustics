#!/usr/bin/env python2

import os, subprocess, sys, errno
from threading import Thread
from gi.repository import GObject, Gtk, GLib
from gi.repository import AppIndicator3 as appindicator
                                        
class MPlayer(object):

    '''
        Class for interfacing with MPlayer. 
        Provides functions to load files, set volume and play/pause
    '''
    
    def __init__(self):
        # Start the mplayer process
        self.mplayer = subprocess.Popen(
                ['mplayer', '-slave', '-quiet', '-idle', '-softvol', '-msglevel', 
                 'statusline=6', '-msglevel', 'global=6', '-really-quiet', '-volume', '0'],
                stdin=subprocess.PIPE, stdout=subprocess.PIPE, bufsize=1)
                
        self.sound_file = '' # This stores the sound file location
        self.name = '' # This stores the name to be read by other classes
        self.volume = 100 # To allow classes to access the output volume

    def load_file (self, filename):
        self.sound_file = filename
        name_start = filename.rfind ('/')
        extension_start = filename.rfind ('.')
        self.name = filename [name_start + 1:extension_start]
        
        self.mplayer.stdin.write('loadfile ' + filename + '\n')
        self.set_volume (self.volume)
        
    def set_volume (self, vol):
        self.volume = vol
        self.mplayer.stdin.write('set volume ' + str (vol) + '\n')
        
    def mute (self): self.mplayer.stdin.write('mute 1\n')
         
    def quit (self):
        self.mplayer.stdin.write('quit\n')
        self.mplayer.kill ()
        return
        
    def pause (self): self.mplayer.stdin.write ('pause\n') # Confusingly, this pauses AND plays it

class Window (Gtk.Window):
    
    ''' 
        Class for providing a graphical interface for the app
    '''
    
    __gsignals__ = {
        'player-volume-changed' : (GObject.SIGNAL_RUN_FIRST, None, (int, object,))
    }
    
    class VolumeScale (Gtk.Scale):
        '''
            A custom widget for the application's volume sliders 
        '''
        __gsignals__ = {
            # args: the new volume and the MPlayer associated with the scale
            'volume-changed' : (GObject.SIGNAL_RUN_LAST, None, (int, object,))
        }
        
        def __init__ (self, player):
            _adjustment = Gtk.Adjustment(100, 0, 100, 1, 10, 0)
            Gtk.Scale.__init__(self, orientation = Gtk.Orientation.HORIZONTAL,
                               adjustment = _adjustment)
            self.set_draw_value (False)
            
            self._player = player
            self.connect ('value-changed', lambda scale_range: \
                                               self.emit("volume-changed", self.get_value (), 
                                                          self._player))
    
    
    def __init__(self, player_list, icon_path, player_volumes):
        Gtk.Window.__init__(self, title = "Acoustics")
        self.set_default_size (475, 375)
        self.build_ui ()
        self.build_player_controls (player_list, icon_path, player_volumes)
        self.show_all ()
        
    def build_ui (self):

        # Headerbar
        self.header = Gtk.HeaderBar ()
        self.header.set_show_close_button (True)
        self.header.set_title ("Acoustics")
        self.header.get_style_context ().add_class ('titlebar')
        self.set_titlebar (self.header)

        # Layouts
        self.layout = Gtk.Grid () 
        
        # Play/Pause Button
        self.play_img = Gtk.Image.new_from_icon_name ('media-playback-start-symbolic', 
                                                       Gtk.IconSize.DIALOG)
        self.pause_img = Gtk.Image.new_from_icon_name ('media-playback-pause-symbolic', 
                                                        Gtk.IconSize.DIALOG)
        self.play_button = Gtk.Button ()
        self.play_button.set_image (self.pause_img)
        self.play_button.get_style_context ().add_class ('flat')
        self.play_button.set_always_show_image (True)
        self.play_button.set_vexpand (False)
        self.play_button.set_hexpand (False)
        self.play_button.set_margin_top (12)
        self.play_button.set_margin_bottom (12)
        self.play_button.set_margin_start (12)
        self.play_button.set_margin_end (6)

        # Volume slider

        value = 100
        adjustment = Gtk.Adjustment(value, 1, 100, 1, 10, 0)

        self.app_vol = Gtk.Scale(orientation=Gtk.Orientation.HORIZONTAL, adjustment=adjustment)
        self.app_vol.set_hexpand(True)
        self.app_vol.set_draw_value (False)
        self.app_vol.set_margin_top (12)
        self.app_vol.set_margin_bottom (12)
        self.app_vol.set_margin_start (6)
        self.app_vol.set_margin_end (12)
        
        self.layout.attach(self.play_button, 0, 0, 1, 1)
        self.layout.attach(self.app_vol, 1, 0, 1, 1)
        
        self.add (self.layout)
        
    def build_player_controls (self, player_list, icon_path, player_volumes):

        icon_grid = Gtk.FlowBox ()
        icon_grid.set_column_spacing (6)
        icon_grid.set_selection_mode (Gtk.SelectionMode.NONE)
        icon_grid.set_max_children_per_line (3)
        icon_grid.set_min_children_per_line (3)
        self.layout.attach(icon_grid, 0, 1, 2, 1)

        #icon_grid = Gtk.Grid ()
        icon_grid.set_margin_start (12)
        icon_grid.set_margin_end (12)
        #self.layout.attach(icon_grid, 0, 1, 2, 1)
        
        for player in player_list:
            box = Gtk.Grid ()
            
            icon_name = icon_path + player.name + '.svg'
            
            image = Gtk.Image.new_from_file (icon_name)
            image.set_hexpand (True)
             
            box.attach (image, 0, 0, 1, 1)
            box.attach (Gtk.Label (player.name.title()), 0, 1, 1, 1)       
            
            sound_vol = self.VolumeScale (player)
            sound_vol.set_value (player_volumes[player.name])
            sound_vol.connect ('volume-changed', lambda arg, val, player: \
                                                     self.emit ('player-volume-changed', val, player))
            sound_vol.set_size_request (108, -1)
            box.attach (sound_vol, 0, 2, 1, 1)
            box.set_hexpand (True)
            #box.set_margin_start (12)
            #box.set_margin_end (12)
            icon_grid.add (box)
            
class App (object):
    
    ''' 
        Main class to connect the backend and frontend
    '''
        
    class State (object):
        PLAYING = 0
        PAUSED = 1
    
    def __init__(self):
        
        # Variables
        self.global_vol = 100
        self.app_state = self.State.PLAYING

        if sys.platform == 'linux2':
            home = os.path.expanduser("~")
            self.data_dir = home + "/.local/share/acoustics/"
            self.sound_dir = self.data_dir + "sounds/"
            self.icon_dir = self.data_dir + "icons/"
                                
        # List to hold mplayer processes
        self.player_list = []
        self.populate_player_list ()
        
        # Create a dictionary to hold volumes for different sounds
        self.player_volumes = {}
        with open (self.data_dir + "config", 'r') as config_file:
            line = config_file.readline()
            while line:
                separator_index = line.rfind(":")
                newline_index = line.rfind("\n")
                player_name = line[:separator_index]
                volume = float(line[separator_index + 1:newline_index])
                print volume
                if player_name == "global": # TODO: fix this
                    self.player_volumes[player_name] = volume 
                else:
                    for player in self.player_list:
                        if player.name == player_name:
                            self.player_volumes[player_name] = volume 
                            player.set_volume (volume)
                    
                line = config_file.readline()
                
        temp_scale = Gtk.Scale ()
        temp_adjust = Gtk.Adjustment (self.player_volumes["global"], 0, 100, 1, 10, 0)
        temp_scale.set_adjustment (temp_adjust)
        self.on_app_volume_change (temp_scale)

        # GUI
        self.win = Window (self.player_list, self.icon_dir, self.player_volumes)
        self.win.connect ("delete-event", self.on_window_close)
        self.win.app_vol.connect ('value-changed', self.on_app_volume_change)
        self.win.play_button.connect ('clicked', self.on_play_button_click)
        self.win.connect ('player-volume-changed', self.on_player_volume_change)
        self.win.app_vol.set_value (self.player_volumes["global"])

        # Indicator
        self.indicator = appindicator.Indicator.new (
                                         "acoustics",
                                         "app-icon",
                                         appindicator.IndicatorCategory.APPLICATION_STATUS)
        self.indicator.set_icon_theme_path (self.icon_dir)
        self.indicator.set_status (appindicator.IndicatorStatus.ACTIVE)
        self.indicator.set_attention_icon ("indicator-messages-new")

        indicator_menu = Gtk.Menu ()
        open_item = Gtk.MenuItem ("Configure")
        open_item.show ()
        open_item.connect ('activate', lambda x: self.win.show_all ())
        indicator_menu.append (open_item)
        
        quit_item = Gtk.MenuItem ("Quit")
        quit_item.connect ('activate', self.on_delete)
        quit_item.show ()
        indicator_menu.append (quit_item)

        self.indicator.set_menu (indicator_menu)

        # Start a new thread to collect any output from mplayer
        self.output_thread = Thread (target = self.read_output)
        self.output_thread.start ()
        
    def populate_player_list (self):
        sound_list = os.listdir (self.sound_dir)
        sound_list.sort ()
        for sound in sound_list:
            player = MPlayer ()
            player.load_file (self.sound_dir + sound)
            self.player_list.append (player)
        
    def on_window_close (self, *args):
        if self.app_state is self.State.PLAYING:
            self.win.hide_on_delete ()
        else:
            self.on_delete (args)
        return True    
        
    def on_delete (self, *args):
        for player in self.player_list:
            player.quit ()
            
        self.output_thread.join ()
        # Write to config file
        with open (self.data_dir + "config", 'r') as config_file:
            lines = config_file.readlines ()
        
        line_no = 0
        for key in self.player_volumes:
            lines[line_no] = key + ":" + str(self.player_volumes[key]) + "\n"
            print lines[line_no]
            if line_no + 1 is not len(lines):
                line_no = line_no + 1 
        
        with open (self.data_dir + "config", 'w') as config_file:
            config_file.writelines(lines)
            
        config_file.close ()
        Gtk.main_quit ()
                
        return True
        
    def on_app_volume_change (self, slider_range):
        # Get new volume, adjust volume of tracks accordingly
        if self.app_state is not self.State.PAUSED:
            for i in range (0, len(self.player_list)):
                # Notes to help me figure out how to math:
                # We want x percent of y percent of 100 (max volume)
                # x is the individual volume
                # y is the global volume
                new_vol = (self.player_list[i].volume / float(100)) * (slider_range.get_value () / float (self.global_vol)) * 100
                self.player_list[i].set_volume (new_vol)
                
            self.global_vol = slider_range.get_value ()
            self.player_volumes["global"] = self.global_vol
        
    # I have no idea why 'args' is needed, but the needed parameters start from
    # player and if you don't put a parameter before that then python complains about
    # tuples :(
    
    def on_player_volume_change (self, args, volume, player):
        # The individual volume sliders show how much percent of the total output volume
        # is played for that sound
        if volume < 5: # If it's less than 5 then the user probably meant to mute it
            player.set_volume (0)
            self.player_volumes[player.name] = 0
            player.mute ()
        else:
            new_vol = (volume / float(100)) * self.global_vol
            self.player_volumes[player.name] = volume
            player.set_volume (new_vol)

    def on_play_button_click (self, button):
        if self.app_state is self.State.PLAYING:
            button.set_image (self.win.play_img)
            self.app_state = self.State.PAUSED
        else:
            button.set_image (self.win.pause_img)
            self.app_state = self.State.PLAYING
                
        for player in self.player_list:
            player.pause () # This pauses if playing and plays if paused
        
    def read_output (self):
        for player in self.player_list:
            for line in iter(player.mplayer.stdout.readline, b''):
                print line
                # This plays the sound again (i.e. loops it) once it has finished
                if 'EOF code: 1' in line:
                    self.player.load_file (self.player.sound_file)

if __name__ == '__main__':
    Gtk.init ()
    app = App ()       
    Gtk.main ()
    
